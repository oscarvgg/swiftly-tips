{"meta":{"title":"Swiftly tips","subtitle":"Tips to improve your Swift knowledge","description":null,"author":"Oscar V. Gonzalez Greco","url":"http://swiftly.tips"},"pages":[],"posts":[{"title":"Swift tutorial: Value types","slug":"6-swift-tutorial-reference-types","date":"2018-11-22T07:53:43.000Z","updated":"2018-11-22T07:57:42.435Z","comments":true,"path":"2018/11/22/6-swift-tutorial-reference-types/","link":"","permalink":"http://swiftly.tips/2018/11/22/6-swift-tutorial-reference-types/","excerpt":"","text":"The other day, I was chatting with some colleagues, who were interviewing people for a Swift Dev job opening. They said the killer question was, what‚Äôs the difference between a ‚Äòstruct‚Äô and a ‚Äòclass‚Äô?. I was surprised. That‚Äôs something every swift developer should know. For that reason, I decided to write this post. what is a reference?Imagine a reference as a link to a value. With a reference, we access the data. Instances of a class are called ‚Äúobjects‚Äù, and you cannot directly assign them to a variable, you reference it. The most common way to create a reference type in Swift is using a class 123class MyClass &#123; var a = 1&#125; Unlike the value types, references do change their referenced value when the assigned variable is mutated. 1234var myClassInstance = MyClass()var anotherInstance = myClassInstanceanotherInstance.a = 2myClassInstance.a Even when a reference is assigned with let, we can still modify properties in the referenced object. 1234let constantReference = MyClass()constantReference.a // = 1constantReference.a = 3constantReference.a // = 3 That means that the constant is the reference, not the object. With value types we wouldn‚Äôt be able to do this. 123456struct MyStruct &#123; var b = 5&#125;let myValue = MyStruct()myValue.b = 8 // Error! ü§Ø Trying to change the value of b in myValue.b = 8 would result in a compiler error. Now let‚Äôs complicate things a little. Let‚Äôs create a value type that contains a reference type. 123456789101112131415161718192021class ReferenceType &#123; var aValueProperty = 5&#125;struct ValueType &#123; var aReference = ReferenceType() var aValue = \"hello\"&#125;// Create the valuelet valueInstance = ValueType()// copy itvar anotherValueInstance = valueInstance// change it's propertiesanotherValueInstance.aReference.aValueProperty = 1000anotherValueInstance.aValue = \"bye\"// Now lets check what changed in the originalvalueInstance.aReference.aValueProperty // 1000valueInstance.aValue // \"hello\" Notice how aValue maintained it‚Äôs original value in valueInstance, whereas aReference.aValueProperty changed for both the original and the copied value, even when it was only modified in the copy. This behaviour is what we call a ‚Äúshallow copy‚Äù, where we copy all the values but the referenced value stays the same. This is because we only copied the references. On the other hand, when we copy absolutely everything, including the referenced values, we call this a ‚Äúdeep copy‚Äù. This may be a little confusing, so take your time to understand it. Equality of Reference Types When we use the equals operator (==), we are checking if two values are the same. 1234561 == 1 // truelet x = 400let y = 250x == y // false The same behaviour doesn‚Äôt occur when comparing custom value types. 12345678struct AnotherValueType &#123; let aValue = 10&#125;let m = AnotherValueType()let n = mm == n // Error: Binary operator '==' cannot be applied to two 'AnotherValueType' operands This behaviour happened because AnotherValueType doesn‚Äôt implement the Equatable protocol, but that‚Äôs a topic for another time. The same happens for reference types. What we can do with reference types is check if they are the same with the === operator 12345678class AnotherClass &#123; let x = [1,2,3]&#125;let j = AnotherClass()let k = jj == k // Error!j === k // üëç The === operator checks if two references point to the same value. FunctionsSurprise! Yes, functions are reference types. You can assign them to variables: 123let aFunction = &#123; return 50&#125; You can pass them as parameters: 12345func anotherFunction(aFunctionAsParameter: () -&gt; Int) -&gt; Int &#123; return aFunctionAsParameter()&#125;anotherFunction(aFunctionAsParameter: aFunction) They are one of the most relevant features of Swift. These kinds of functions that receive another function as a parameter are called ‚Äúhigher order functions‚Äù. Some famous ones are: map, reduce, filter, among others. 12345678let grades = [10,5,3,9]// lets see who passed:let passed = grades.filter &#123; (aGrade) -&gt; Bool in return aGrade &gt;= 5&#125;// passed = [10,5,9] Functions can be declared inside other functions, like in a for-loop or inside many other scopes. But since functions are reference types when they are declared inside another scope and passed further, after the local scope ends, the local variables used inside the function aren‚Äôt destroyed. 12345678func outerFunction() -&gt; () -&gt; String &#123; let aVariable = \"Hello from outer function\" let innerFunction = &#123; return aVariable &#125; return innerFunction&#125;outerFunction()() The functions that hold variables outside of their scope are usually called closures. But it doesn‚Äôt mean that other functions declared with func aren‚Äôt also closures. Not The End Having a good understanding of how types work in Swift will help you decide when to use what, and more significantly, to better architect your apps. Please, let me know your thoughts and questions.","categories":[],"tags":[]},{"title":"Swift tutorial: Value types","slug":"5-swift-tutorial-value-types","date":"2018-11-09T08:10:05.000Z","updated":"2018-11-22T08:06:17.168Z","comments":true,"path":"2018/11/09/5-swift-tutorial-value-types/","link":"","permalink":"http://swiftly.tips/2018/11/09/5-swift-tutorial-value-types/","excerpt":"","text":"I created this site to help people improve their code. And that‚Äôs still the mission today. Over the years, and especially in the recent months, I‚Äôve seen so many young programmers get confused with some of the basic foundations of Swift. That‚Äôs why I decided to create this series of swift tutorials explaining the basics of the language. So, let‚Äôs get started! What is Swift and why Apple created it?Swift is a programming language created by Apple. It‚Äôs easy to learn, but in my opinion difficult to master, however, the easy part will do for most of what you‚Äôll need. Swift is a strongly typed language and has a familiar syntax for developers that come from other famous languages. Swift was created, among other reasons, to make building apps for the Apple platform beginner friendly. Previously the scene was dominated by Objective-C. A powerful language with a syntax peculiar enough to confuse less experienced developers. Therefore, Apple came with this new pleasant-to-write language, not only attract young developers but also the very experienced ones. If you want to learn more about what is Swift, you can visit the official website. What is a type?A type is an attribute we give to our data to tell the compiler how we intend to use it. In Swift, there are two kinds of data types: the ‚Äúvalue‚Äù types and the ‚Äúreference‚Äù types. To keep the right pace, in this article we are going to talk about just value types. What is a value?A value is an instance of some data, like a number or text. In Swift, most of the commonly used value types are represented with struct, like Int, Bool, String, etc. But also another common way to represent a value type is enum. Here are some examples of values in Swift: 123true\"Hello!\"[1,2,3,4] But what do we do with just values? We need to be able to identify them so we can move them around. Introducing VariablesSo again, what do we do with a value? We store it and run operations on it. How? Well, first we need to label it. A variable is just a label that helps you identify your value for later use. 1var a = \"Hello world\" It‚Äôs important to understand, that When we run an operation that mutates our value, we don‚Äôt change the original, but instead, a new one gets created and replaces the old value. Knowing this will help you decide what kind of data type to use when coding. 123var b = [\"Hello\", \"World\"]b.append(\"!\")// b = [\"Hello\", \"World\", \"!\"] ConstantsConstants are mostly like variables but, once they‚Äôre assigned with a value, they cannot be reassigned. In Swift, they are declared with the keyword let. 1let c = 1 Trying to assign c = 2 will result in a compiler error Passing Values AroundWhen working with value types, if we assign a variable to another, the value gets copied from one to the other. While the two variables may have the same value, changing one won‚Äôt affect the other. 123var d = b // [\"Hello\", \"World\", \"!\"]d.append(\"from Italy\")// [\"Hello\", \"World\", \"!\", \"from Italy\"] Notice how b stays the same, while the value of d changed. ConclusionThis is all for now about value types in Swift. Hope you liked it and feel excited to go and play with what you‚Äôve learned. On the next part, I‚Äôm going to talk about reference types. If you like what you just read or want me to continue writing about the Swift basics, please subscribe to receive on your email a monthly summary of the activity of the blog. Also, please share this content to keep me motivated. And if you have any questions or something to add, let me know on the comments section below. Bye üòâ","categories":[],"tags":[{"name":"basics","slug":"basics","permalink":"http://swiftly.tips/tags/basics/"},{"name":"tutorial","slug":"tutorial","permalink":"http://swiftly.tips/tags/tutorial/"}]},{"title":"Swift Tip - Using variadic parameters","slug":"4-using-variadic-parameters","date":"2018-04-24T09:28:13.000Z","updated":"2018-11-22T07:55:37.141Z","comments":true,"path":"2018/04/24/4-using-variadic-parameters/","link":"","permalink":"http://swiftly.tips/2018/04/24/4-using-variadic-parameters/","excerpt":"","text":"Want your array parameters to look way cooler? Boring12345func trapInUpsideDown(people: [String]) &#123; // ... your code here&#125;trapInUpsideDown(people: [‚ÄúDustin‚Äù,‚ÄùMike‚Äù,‚ÄùLucas‚Äù, \"Will\"]) Cooler look12345func trapInUpsideDown(_ people: String...) &#123; // ... your code here&#125;trapInUpsideDown(‚ÄúDustin‚Äù,‚ÄùMike‚Äù,‚ÄùLucas‚Äù, \"Will\") üòâ","categories":[],"tags":[{"name":"style","slug":"style","permalink":"http://swiftly.tips/tags/style/"},{"name":"syntax","slug":"syntax","permalink":"http://swiftly.tips/tags/syntax/"}]},{"title":"Swift Tip - Printing multiple variables at once?","slug":"3-print-multiple-things","date":"2018-04-24T09:15:33.000Z","updated":"2018-11-22T07:55:29.819Z","comments":true,"path":"2018/04/24/3-print-multiple-things/","link":"","permalink":"http://swiftly.tips/2018/04/24/3-print-multiple-things/","excerpt":"","text":"Wanna print multiple variables? Problem12345let name = \"Tony\"let lastName: \"Stark\"print(name)print(lastName) Better solutionWrap them on a tuple. 1234let name = \"Tony\"let lastName: \"Stark\"print((name, lastName)) Awh, syntactic sugar ‚ò∫Ô∏è","categories":[],"tags":[{"name":"style","slug":"style","permalink":"http://swiftly.tips/tags/style/"}]},{"title":"Swift Tip - Ditch the semicolon","slug":"2-Ditch-the-semicolon","date":"2017-12-06T23:44:52.000Z","updated":"2018-11-22T07:55:23.573Z","comments":true,"path":"2017/12/07/2-Ditch-the-semicolon/","link":"","permalink":"http://swiftly.tips/2017/12/07/2-Ditch-the-semicolon/","excerpt":"","text":"Every time you use a semicolon (;) in swift, a tree dies üôÑ. Don‚Äôt roll your eyes! It‚Äôs true. Don‚Äôt use them, they are a thing of the past. They make your code look ugly and nasty. Look how ugly: 12let lukeSkywalker = JediKnight();lukeSkywalker.savePrincessLeia(); Now look how beautiful: 12let lukeSkywalker = JediKnight()lukeSkywalker.savePrincessLeia() Nice, clean, perfect üòå.","categories":[],"tags":[{"name":"style","slug":"style","permalink":"http://swiftly.tips/tags/style/"}]},{"title":"Swift Tip - Closure retain cycle","slug":"1-closure-retain-cycle","date":"2017-11-30T19:07:08.000Z","updated":"2018-11-22T07:55:17.280Z","comments":true,"path":"2017/11/30/1-closure-retain-cycle/","link":"","permalink":"http://swiftly.tips/2017/11/30/1-closure-retain-cycle/","excerpt":"","text":"Avoid calling self inside your closure as much as possible. 123let tower = &#123; [weak self] rapunzel in return self?.knight.save(rapunzel)&#125; What if self is nil? I know what you‚Äôre thinking. Forget unowned! Just pass a capture list with the properties you need inside the closure. 123let tower = &#123; [knight] rapunzel in return knight.save(rapunzel)&#125; And that is how it is done.","categories":[],"tags":[{"name":"memory","slug":"memory","permalink":"http://swiftly.tips/tags/memory/"}]}]}